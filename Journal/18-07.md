# Teach Yourself Computer Science
## Progress Journal

## July, 2018

### 5th
- Read about integrations on [MathIsFun](https://www.mathsisfun.com/calculus/integration-definite.html) to try to understand them in order to be able to do _Structure and Interpretation of Computer Programs_ exercise 1.29

### 7th
- Watched L03 Higher Order Procedures | UC Berkeley CS 61A, Spring 2010
- Watched L04 Higher Order Procedures | UC Berkeley CS 61A, Spring 2010

### 9th
- Did about half of _SICP_ exercise 1.31
- Recursive analogous procedure `product`:
```scheme
(define (product fun start next stop)
  (if (equal? start stop)
    (fun stop)
    (* (fun start) (product fun (next start) next stop))
  )
)
```
- Define `factorial` in terms of `product`:
```scheme
(define (factorial x)
  (product (lambda (x) x) x (lambda (x) (- x 1)) 1))
```

### 11th
- Wrote an iterative version of the `product` procedure for exercise 1.31
```scheme
(define (product fun start next stop)
  (define (iter str stp result)
    (if (equal? str stp)
      result
      (iter (next str) stp (* result (fun str)))
    )
  )
  (iter start stop 1)
)
```

### 12th
- Finished exercise 1.31
- Used my `product` procedure to approximate pi using John Wallis' formula
```scheme
(define (approx_pi times)
  (*
    (product
      (lambda (n)
        (* (/ (* 2 n) (- (* 2 n) 1))
          (/ (* 2 n) (+ (* 2 n) 1)))
      )
      1
      (lambda (x) (+ x 1))
      times)
    2)
)
```